%
% API Documentation for API Documentation
% Module datk.core.algs
%
% Generated by epydoc 3.0.1
% [Thu Dec 10 12:07:17 2015]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}|(}
\section{Module datk.core.algs}

    \label{datk:core:algs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               Variables                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsection{Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright \_\-\_\-p\-a\-c\-k\-a\-g\-e\-\_\-\_\- & \raggedright \textbf{Value:} 
{\tt \texttt{'}\texttt{datk.core}\texttt{'}}&\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.LCR \textit{(class)}|(}
\subsection{Class LCR}

    \label{datk:core:algs:LCR}
\begin{tabular}{cccccccc}
% Line for datk.core.distalgs.Algorithm, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{datk.core.distalgs.Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Algorithm}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for datk.core.distalgs.Synchronous\_Algorithm, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{datk.core.algs.LCR}}
\end{tabular}

The LeLann, Chang and Roberts algorithm for Leader Election in a 
Synchronous Ring Network

Each Process sends its identifier around the ring. When a Process receives 
an incoming identifier, it compares that identifier to its own. If the 
incoming identifier is greater than its own, it keeps passing the 
identifier; if it is less than its own, it discards the incoming 
identifier; if it is equal to its own, the Process declares itself the 
leader.

Requires:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Every process knows state['n'], the size of the network

\end{itemize}

Effects:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Every process has state['status'] is 'leader' or 'non-leader'.

  \item Exactly one process has state['status'] is 'leader'

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{msgs\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what messages a Process, p, will send.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.msgs\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_i}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
    Determines what state transition a Process, p, will perform, having 
    received messages, msgs

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.trans\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{cleanup\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what final state transition a Process, p, will perform, 
    after the algorithm terminates.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.cleanup\_i 	extit{(inherited documentation)}

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from datk.core.distalgs.Synchronous\_Algorithm\textit{(Section \ref{datk:core:distalgs:Synchronous_Algorithm})}}}}

\begin{quote}
execute(), msgs(), round(), run(), trans()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Algorithm\textit{(Section \ref{datk:core:distalgs:Algorithm})}}}}

\begin{quote}
\_\_call\_\_(), \_\_init\_\_(), cleanup(), count\_msg(), delete(), get(), halt(), halt\_i(), has(), increment(), set()
\end{quote}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.LCR \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.AsyncLCR \textit{(class)}|(}
\subsection{Class AsyncLCR}

    \label{datk:core:algs:AsyncLCR}
\begin{tabular}{cccccccc}
% Line for datk.core.distalgs.Algorithm, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{datk.core.distalgs.Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Algorithm}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for datk.core.distalgs.Asynchronous\_Algorithm, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{datk.core.distalgs.Asynchronous\_Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Asynchronous\_Algorithm}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{datk.core.algs.AsyncLCR}}
\end{tabular}

The LeLann, Chang and Roberts algorithm for Leader Election in an 
Asynchronous Ring Network

Each Process sends its identifier around the ring. When a Process receives 
incoming identifier(s), it compares their largest to its own. If that 
incoming identifier is greater than its own, it keeps passing that 
identifier; if it is less than its own, it discards all the incoming 
identifiers; if it is equal to its own, the Process declares itself the 
leader. When a Process has declared itself Leader, it sends a Leader 
Declaration message around the ring, and halts As it goes around the ring, 
each other Process outputs 'non-leader', and halts.

Requires:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Every process knows state['n'], the size of the network

\end{itemize}

Effects:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Every process has state['status'] is 'leader' or 'non-leader'.

  \item Exactly one process has state['status'] is 'leader'

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{msgs\_i}(\textit{self}, \textit{p}, \textit{verbose}={\tt False})

\setlength{\parskip}{2ex}
    Determines what messages a Process, p, will send.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.msgs\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_i}(\textit{self}, \textit{p}, \textit{verbose}={\tt False})

\setlength{\parskip}{2ex}
    Determines what state transition a Process, p, will perform, having 
    received messages, msgs

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.trans\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{cleanup\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what final state transition a Process, p, will perform, 
    after the algorithm terminates.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.cleanup\_i 	extit{(inherited documentation)}

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from datk.core.distalgs.Asynchronous\_Algorithm\textit{(Section \ref{datk:core:distalgs:Asynchronous_Algorithm})}}}}

\begin{quote}
run(), run\_process()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Algorithm\textit{(Section \ref{datk:core:distalgs:Algorithm})}}}}

\begin{quote}
\_\_call\_\_(), \_\_init\_\_(), cleanup(), count\_msg(), delete(), get(), halt(), halt\_i(), has(), increment(), set()
\end{quote}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.AsyncLCR \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.FloodMax \textit{(class)}|(}
\subsection{Class FloodMax}

    \label{datk:core:algs:FloodMax}
\begin{tabular}{cccccccc}
% Line for datk.core.distalgs.Algorithm, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{datk.core.distalgs.Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Algorithm}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for datk.core.distalgs.Synchronous\_Algorithm, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{datk.core.algs.FloodMax}}
\end{tabular}

UID flooding algorithm for Leader Election in a general network

Every process maintains a record of the maximum UID it has seen so far 
(initially its own). At each round, each process propagates this maximum on
all of its outgoing edges. After diam rounds, if the maximum value seen is 
the process's own UID, the process elects itself the leader; otherwise, it 
is a non-leader.

Requires:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Every process, p, has p.state["diam"] {\textgreater}= dist( p, q ), 
    forall q.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{msgs\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what messages a Process, p, will send.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.msgs\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_i}(\textit{self}, \textit{p}, \textit{msgs}, \textit{verbose}={\tt False})

\setlength{\parskip}{2ex}
    Determines what state transition a Process, p, will perform, having 
    received messages, msgs

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.trans\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{cleanup\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what final state transition a Process, p, will perform, 
    after the algorithm terminates.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.cleanup\_i 	extit{(inherited documentation)}

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from datk.core.distalgs.Synchronous\_Algorithm\textit{(Section \ref{datk:core:distalgs:Synchronous_Algorithm})}}}}

\begin{quote}
execute(), msgs(), round(), run(), trans()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Algorithm\textit{(Section \ref{datk:core:distalgs:Algorithm})}}}}

\begin{quote}
\_\_call\_\_(), \_\_init\_\_(), cleanup(), count\_msg(), delete(), get(), halt(), halt\_i(), has(), increment(), set()
\end{quote}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.FloodMax \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchBFS \textit{(class)}|(}
\subsection{Class SynchBFS}

    \label{datk:core:algs:SynchBFS}
\begin{tabular}{cccccccc}
% Line for datk.core.distalgs.Algorithm, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{datk.core.distalgs.Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Algorithm}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for datk.core.distalgs.Synchronous\_Algorithm, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{datk.core.algs.SynchBFS}}
\end{tabular}

Constructs a BFS tree with the 'leader' Process at its root

At any point during execution, there is some set of processes that is 
"marked," initially just i0. Process i0 sends out a search message at round
1, to all of its outgoing neighbors. At any round, if an unmarked process 
receives a search message, it marks itself and chooses one of the processes
from which the search has arrived as its parent. At the first round after a
process gets marked, it sends a search message to all of its outgoing 
neighbors.

Requires:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item testLeaderElection

\end{itemize}

Effects:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item every Process has state['parent']. Leader has state['parent'] = None

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{datk:core:algs:SynchBFS:is_i0}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchBFS \textit{(class)}!datk.core.algs.SynchBFS.is\_i0 \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{is\_i0}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{msgs\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what messages a Process, p, will send.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.msgs\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_i}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
    Determines what state transition a Process, p, will perform, having 
    received messages, msgs

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.trans\_i 	extit{(inherited documentation)}

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from datk.core.distalgs.Synchronous\_Algorithm\textit{(Section \ref{datk:core:distalgs:Synchronous_Algorithm})}}}}

\begin{quote}
execute(), msgs(), round(), run(), trans()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Algorithm\textit{(Section \ref{datk:core:distalgs:Algorithm})}}}}

\begin{quote}
\_\_call\_\_(), \_\_init\_\_(), cleanup(), cleanup\_i(), count\_msg(), delete(), get(), halt(), halt\_i(), has(), increment(), set()
\end{quote}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchBFS \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchBFSAck \textit{(class)}|(}
\subsection{Class SynchBFSAck}

    \label{datk:core:algs:SynchBFSAck}
\begin{tabular}{cccccccc}
% Line for datk.core.distalgs.Algorithm, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{datk.core.distalgs.Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Algorithm}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for datk.core.distalgs.Synchronous\_Algorithm, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{datk.core.algs.SynchBFSAck}}
\end{tabular}

Constructs a BFS tree with children pointers and the 'leader' Process at 
its root

Algorithm (Informal): At any point during execution, there is some set of 
processes that is "marked," initially just i0. Process i0 sends out a 
search message at round 1, to all of its outgoing neighbors. At any round, 
if an unmarked process receives a search message, it marks itself and 
chooses one of the processes from which the search arrived as its parent. 
At the first round after a process gets marked, it sends a search message 
to all of its outgoing neighbors, and an acknowledgement to its parent, so 
that nodes will also know their children.

Requires:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item testLeaderElection

\end{itemize}

Effects:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Every process knows:

    \begin{itemize}
    \setlength{\parskip}{0.6ex}
      \item state['parent']. Leader has state['parent'] = None

      \item state['childen']. Leaves have state['children'] = []

    \end{itemize}

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{datk:core:algs:SynchBFSAck:is_i0}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchBFSAck \textit{(class)}!datk.core.algs.SynchBFSAck.is\_i0 \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{is\_i0}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{msgs\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what messages a Process, p, will send.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.msgs\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_i}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
    Determines what state transition a Process, p, will perform, having 
    received messages, msgs

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.trans\_i 	extit{(inherited documentation)}

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from datk.core.distalgs.Synchronous\_Algorithm\textit{(Section \ref{datk:core:distalgs:Synchronous_Algorithm})}}}}

\begin{quote}
execute(), msgs(), round(), run(), trans()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Algorithm\textit{(Section \ref{datk:core:distalgs:Algorithm})}}}}

\begin{quote}
\_\_call\_\_(), \_\_init\_\_(), cleanup(), cleanup\_i(), count\_msg(), delete(), get(), halt(), halt\_i(), has(), increment(), set()
\end{quote}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchBFSAck \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchConvergecast \textit{(class)}|(}
\subsection{Class SynchConvergecast}

    \label{datk:core:algs:SynchConvergecast}
\begin{tabular}{cccccccc}
% Line for datk.core.distalgs.Algorithm, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{datk.core.distalgs.Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Algorithm}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for datk.core.distalgs.Synchronous\_Algorithm, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{datk.core.algs.SynchConvergecast}}
\end{tabular}

\textbf{Known Subclasses:} datk.core.algs.SynchConvergeHeight

The abstract superclass of a class of Synchronous Algorithms that propagate
information from the leaves of a BFS tree to its root.

Requires:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Every Process knows state['parent']

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{datk:core:algs:SynchConvergecast:is_root}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchConvergecast \textit{(class)}!datk.core.algs.SynchConvergecast.is\_root \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{is\_root}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{msgs\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what messages a Process, p, will send.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.msgs\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_i}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
    Determines what state transition a Process, p, will perform, having 
    received messages, msgs

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.trans\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{cleanup\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what final state transition a Process, p, will perform, 
    after the algorithm terminates.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.cleanup\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \label{datk:core:algs:SynchConvergecast:trans_root}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchConvergecast \textit{(class)}!datk.core.algs.SynchConvergecast.trans\_root \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_root}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{datk:core:algs:SynchConvergecast:output_root}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchConvergecast \textit{(class)}!datk.core.algs.SynchConvergecast.output\_root \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{output\_root}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{datk:core:algs:SynchConvergecast:initial_msg_to_parent}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchConvergecast \textit{(class)}!datk.core.algs.SynchConvergecast.initial\_msg\_to\_parent \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{initial\_msg\_to\_parent}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{datk:core:algs:SynchConvergecast:trans_msg_to_parent}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchConvergecast \textit{(class)}!datk.core.algs.SynchConvergecast.trans\_msg\_to\_parent \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_msg\_to\_parent}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}


\large{\textbf{\textit{Inherited from datk.core.distalgs.Synchronous\_Algorithm\textit{(Section \ref{datk:core:distalgs:Synchronous_Algorithm})}}}}

\begin{quote}
execute(), msgs(), round(), run(), trans()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Algorithm\textit{(Section \ref{datk:core:distalgs:Algorithm})}}}}

\begin{quote}
\_\_call\_\_(), \_\_init\_\_(), cleanup(), count\_msg(), delete(), get(), halt(), halt\_i(), has(), increment(), set()
\end{quote}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchConvergecast \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.AsynchConvergecast \textit{(class)}|(}
\subsection{Class AsynchConvergecast}

    \label{datk:core:algs:AsynchConvergecast}
\begin{tabular}{cccccccc}
% Line for datk.core.distalgs.Algorithm, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{datk.core.distalgs.Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Algorithm}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for datk.core.distalgs.Asynchronous\_Algorithm, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{datk.core.distalgs.Asynchronous\_Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Asynchronous\_Algorithm}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{datk.core.algs.AsynchConvergecast}}
\end{tabular}

\textbf{Known Subclasses:} datk.core.algs.AsynchConvergeHeight

The abstract superclass of a class of Asynchronous Algorithms that 
propagate information from the leaves of a BFS tree to its root.

Requires:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Every Process knows state['parent'] and state['children']

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \label{datk:core:algs:AsynchConvergecast:is_root}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.AsynchConvergecast \textit{(class)}!datk.core.algs.AsynchConvergecast.is\_root \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{is\_root}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{msgs\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what messages a Process, p, will send.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.msgs\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_i}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
    Determines what state transition a Process, p, will perform, having 
    received messages, msgs

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.trans\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{cleanup\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what final state transition a Process, p, will perform, 
    after the algorithm terminates.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.cleanup\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \label{datk:core:algs:AsynchConvergecast:trans_root}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.AsynchConvergecast \textit{(class)}!datk.core.algs.AsynchConvergecast.trans\_root \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_root}(\textit{self}, \textit{p}, \textit{msgs})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Determines the state transition the root node should undergo when it 
    receives messages

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxx}

          \item[p]

          the root Process

          \item[msgs]

          the messages received by the root Process, from its BFS children

        \end{Ventry}

      \end{quote}

    \end{boxedminipage}

    \label{datk:core:algs:AsynchConvergecast:output_root}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.AsynchConvergecast \textit{(class)}!datk.core.algs.AsynchConvergecast.output\_root \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{output\_root}(\textit{self}, \textit{p})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Determines the output action, if any, that the root should perform at 
    the end of the Convergecast.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{datk:core:algs:AsynchConvergecast:initial_msg_to_parent}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.AsynchConvergecast \textit{(class)}!datk.core.algs.AsynchConvergecast.initial\_msg\_to\_parent \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{initial\_msg\_to\_parent}(\textit{self}, \textit{p})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Defines the initial message sent from a leaf process to its parent at 
    the beginning of the Convergecast

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{x}

          \item[p]

          A Process at a leaf of the BFS tree

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      the Message p should send to its state['parent']

      \end{quote}

    \end{boxedminipage}

    \label{datk:core:algs:AsynchConvergecast:trans_msg_to_parent}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.AsynchConvergecast \textit{(class)}!datk.core.algs.AsynchConvergecast.trans\_msg\_to\_parent \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_msg\_to\_parent}(\textit{self}, \textit{p}, \textit{msgs})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Defines the message a non-leaf, non-root Process should send to its 
    parent when it has received all its children's messages

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxx}

          \item[p]

          a Process that has both p.state['parent'] != null, and 
          p.state['children'] not empty

          \item[msgs]

          A list of messages from every child of p (in p.state['children'])

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      the Message p should send to its state['parent']

      \end{quote}

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from datk.core.distalgs.Asynchronous\_Algorithm\textit{(Section \ref{datk:core:distalgs:Asynchronous_Algorithm})}}}}

\begin{quote}
run(), run\_process()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Algorithm\textit{(Section \ref{datk:core:distalgs:Algorithm})}}}}

\begin{quote}
\_\_call\_\_(), \_\_init\_\_(), cleanup(), count\_msg(), delete(), get(), halt(), halt\_i(), has(), increment(), set()
\end{quote}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.AsynchConvergecast \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchConvergeHeight \textit{(class)}|(}
\subsection{Class SynchConvergeHeight}

    \label{datk:core:algs:SynchConvergeHeight}
\begin{tabular}{cccccccccc}
% Line for datk.core.distalgs.Algorithm, linespec=[False, False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{datk.core.distalgs.Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Algorithm}}
&&
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
&&
  \\
% Line for datk.core.distalgs.Synchronous\_Algorithm, linespec=[False, False]
\multicolumn{4}{r}{\settowidth{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}}
&&
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for datk.core.algs.SynchConvergecast, linespec=[False]
\multicolumn{6}{r}{\settowidth{\BCL}{datk.core.algs.SynchConvergecast}\multirow{2}{\BCL}{datk.core.algs.SynchConvergecast}}
&&
  \\\cline{7-7}
  &&&&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&&&\multicolumn{2}{l}{\textbf{datk.core.algs.SynchConvergeHeight}}
\end{tabular}

A Convergecast Algorithm that results in the root node, p, knowing 
p.state['height'], the height of the tree rooted at p.

Requires:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item BFS Tree

\end{itemize}

Effects:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Root Process knows height of tree in state["height"]

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{cleanup\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what final state transition a Process, p, will perform, 
    after the algorithm terminates.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.cleanup\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{initial\_msg\_to\_parent}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
      Overrides: datk.core.algs.SynchConvergecast.initial\_msg\_to\_parent

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{output\_root}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
      Overrides: datk.core.algs.SynchConvergecast.output\_root

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_msg\_to\_parent}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
      Overrides: datk.core.algs.SynchConvergecast.trans\_msg\_to\_parent

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_root}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
      Overrides: datk.core.algs.SynchConvergecast.trans\_root

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from datk.core.algs.SynchConvergecast\textit{(Section \ref{datk:core:algs:SynchConvergecast})}}}}

\begin{quote}
is\_root(), msgs\_i(), trans\_i()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Synchronous\_Algorithm\textit{(Section \ref{datk:core:distalgs:Synchronous_Algorithm})}}}}

\begin{quote}
execute(), msgs(), round(), run(), trans()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Algorithm\textit{(Section \ref{datk:core:distalgs:Algorithm})}}}}

\begin{quote}
\_\_call\_\_(), \_\_init\_\_(), cleanup(), count\_msg(), delete(), get(), halt(), halt\_i(), has(), increment(), set()
\end{quote}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchConvergeHeight \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.AsynchConvergeHeight \textit{(class)}|(}
\subsection{Class AsynchConvergeHeight}

    \label{datk:core:algs:AsynchConvergeHeight}
\begin{tabular}{cccccccccc}
% Line for datk.core.distalgs.Algorithm, linespec=[False, False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{datk.core.distalgs.Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Algorithm}}
&&
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
&&
  \\
% Line for datk.core.distalgs.Asynchronous\_Algorithm, linespec=[False, False]
\multicolumn{4}{r}{\settowidth{\BCL}{datk.core.distalgs.Asynchronous\_Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Asynchronous\_Algorithm}}
&&
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for datk.core.algs.AsynchConvergecast, linespec=[False]
\multicolumn{6}{r}{\settowidth{\BCL}{datk.core.algs.AsynchConvergecast}\multirow{2}{\BCL}{datk.core.algs.AsynchConvergecast}}
&&
  \\\cline{7-7}
  &&&&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&&&\multicolumn{2}{l}{\textbf{datk.core.algs.AsynchConvergeHeight}}
\end{tabular}

A Convergecast Algorithm that results in the root node, p, knowing 
p.state['height'], the height of the tree rooted at p.

Requires:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item BFS Tree

\end{itemize}

Effects:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Root Process knows height of tree in state["height"]

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{cleanup\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what final state transition a Process, p, will perform, 
    after the algorithm terminates.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.cleanup\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{initial\_msg\_to\_parent}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Defines the initial message sent from a leaf process to its parent at 
    the beginning of the Convergecast

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{x}

          \item[p]

          A Process at a leaf of the BFS tree

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      the Message p should send to its state['parent']

      \end{quote}

      Overrides: datk.core.algs.AsynchConvergecast.initial\_msg\_to\_parent 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{output\_root}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines the output action, if any, that the root should perform at 
    the end of the Convergecast.

\setlength{\parskip}{1ex}
      Overrides: datk.core.algs.AsynchConvergecast.output\_root 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_msg\_to\_parent}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
    Defines the message a non-leaf, non-root Process should send to its 
    parent when it has received all its children's messages

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxx}

          \item[p]

          a Process that has both p.state['parent'] != null, and 
          p.state['children'] not empty

          \item[msgs]

          A list of messages from every child of p (in p.state['children'])

        \end{Ventry}

      \end{quote}

      \textbf{Return Value}
    \vspace{-1ex}

      \begin{quote}
      the Message p should send to its state['parent']

      \end{quote}

      Overrides: datk.core.algs.AsynchConvergecast.trans\_msg\_to\_parent 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_root}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
    Determines the state transition the root node should undergo when it 
    receives messages

\setlength{\parskip}{1ex}
      \textbf{Parameters}
      \vspace{-1ex}

      \begin{quote}
        \begin{Ventry}{xxxx}

          \item[p]

          the root Process

          \item[msgs]

          the messages received by the root Process, from its BFS children

        \end{Ventry}

      \end{quote}

      Overrides: datk.core.algs.AsynchConvergecast.trans\_root 	extit{(inherited documentation)}

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from datk.core.algs.AsynchConvergecast\textit{(Section \ref{datk:core:algs:AsynchConvergecast})}}}}

\begin{quote}
is\_root(), msgs\_i(), trans\_i()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Asynchronous\_Algorithm\textit{(Section \ref{datk:core:distalgs:Asynchronous_Algorithm})}}}}

\begin{quote}
run(), run\_process()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Algorithm\textit{(Section \ref{datk:core:distalgs:Algorithm})}}}}

\begin{quote}
\_\_call\_\_(), \_\_init\_\_(), cleanup(), count\_msg(), delete(), get(), halt(), halt\_i(), has(), increment(), set()
\end{quote}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.AsynchConvergeHeight \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchBroadcast \textit{(class)}|(}
\subsection{Class SynchBroadcast}

    \label{datk:core:algs:SynchBroadcast}
\begin{tabular}{cccccccc}
% Line for datk.core.distalgs.Algorithm, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{datk.core.distalgs.Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Algorithm}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for datk.core.distalgs.Synchronous\_Algorithm, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{datk.core.algs.SynchBroadcast}}
\end{tabular}

Broadcasts a value stored in Process, p, to the BFS tree rooted at p

Requires:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item The attribute to be broadcasted must be specified in 
    self.params['attr']

  \item BFS Tree with children pointers, where root node has 
    state[self.params['attr']]

\end{itemize}

Effects:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item All Processes have state[self.params['attr']] := the original value of 
    in state[self.params['attr']] of the root Process.

\end{itemize}

For example: If the root Process, p, knows p.state['min\_UID'] = 4. Then 
after the execution, all Processes q in the Network know 
q.state['min\_UID'].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{msgs\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what messages a Process, p, will send.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.msgs\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_i}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
    Determines what state transition a Process, p, will perform, having 
    received messages, msgs

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.trans\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{cleanup\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what final state transition a Process, p, will perform, 
    after the algorithm terminates.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.cleanup\_i 	extit{(inherited documentation)}

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from datk.core.distalgs.Synchronous\_Algorithm\textit{(Section \ref{datk:core:distalgs:Synchronous_Algorithm})}}}}

\begin{quote}
execute(), msgs(), round(), run(), trans()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Algorithm\textit{(Section \ref{datk:core:distalgs:Algorithm})}}}}

\begin{quote}
\_\_call\_\_(), \_\_init\_\_(), cleanup(), count\_msg(), delete(), get(), halt(), halt\_i(), has(), increment(), set()
\end{quote}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchBroadcast \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchLubyMIS \textit{(class)}|(}
\subsection{Class SynchLubyMIS}

    \label{datk:core:algs:SynchLubyMIS}
\begin{tabular}{cccccccc}
% Line for datk.core.distalgs.Algorithm, linespec=[False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{datk.core.distalgs.Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Algorithm}}
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for datk.core.distalgs.Synchronous\_Algorithm, linespec=[False]
\multicolumn{4}{r}{\settowidth{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}\multirow{2}{\BCL}{datk.core.distalgs.Synchronous\_Algorithm}}
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&\multicolumn{2}{l}{\textbf{datk.core.algs.SynchLubyMIS}}
\end{tabular}

A randomized algorithm that constructs a Maximal Independent Set

The algorithm works in stages, each consisting of three rounds.

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Round 1: In the first round of a stage, the processes choose their 
    respective vals and send them to their neighbors. By the end of round 
    1, when all the val messages have been received, the winners--that is, 
    the processes in F--know who they are.

  \item Round 2: In the second round, the winners notify their neighbors. By 
    the end of round 2, the losers--that is, the processes having neighbors
    in F--know who they are.

  \item Round 3: In the third round, each loser notifies its neighbors. Then 
    all the involved processes--the winners, the losers, and the losers' 
    neighbors-- remove the appropriate nodes and edges from the graph. More
    precisely, this means the winners and losers discontinue participation 
    after this stage, and the losers' neighbors remove all the edges that 
    are incident on the newly removed nodes.

\end{itemize}

Requires:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Every process knows state['n'], the size of the network

\end{itemize}

Effect:

\begin{itemize}
\setlength{\parskip}{0.6ex}
  \item Every process knows state['MIS']. A boolean representing whether it is 
    a member of the Maximal Independent Set found by Luby's algorithm.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{msgs\_i}(\textit{self}, \textit{p})

\setlength{\parskip}{2ex}
    Determines what messages a Process, p, will send.

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.msgs\_i 	extit{(inherited documentation)}

    \end{boxedminipage}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{trans\_i}(\textit{self}, \textit{p}, \textit{msgs})

\setlength{\parskip}{2ex}
    Determines what state transition a Process, p, will perform, having 
    received messages, msgs

\setlength{\parskip}{1ex}
      Overrides: datk.core.distalgs.Algorithm.trans\_i 	extit{(inherited documentation)}

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from datk.core.distalgs.Synchronous\_Algorithm\textit{(Section \ref{datk:core:distalgs:Synchronous_Algorithm})}}}}

\begin{quote}
execute(), msgs(), round(), run(), trans()
\end{quote}

\large{\textbf{\textit{Inherited from datk.core.distalgs.Algorithm\textit{(Section \ref{datk:core:distalgs:Algorithm})}}}}

\begin{quote}
\_\_call\_\_(), \_\_init\_\_(), cleanup(), cleanup\_i(), count\_msg(), delete(), get(), halt(), halt\_i(), has(), increment(), set()
\end{quote}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}!datk.core.algs.SynchLubyMIS \textit{(class)}|)}
    \index{datk \textit{(package)}!datk.core \textit{(package)}!datk.core.algs \textit{(module)}|)}
